# ------------------의사 코드-----------------------
# add 할 때 길이별로 비교할 범주를 만들면 좋을듯함.
# 최대 검색어는 10000개이다.
# 입력받을 때, 해당 문자열의 길이를 키로 딕셔너리의 리스트에 append한다. ( default dict 함수 사용 Keyerror 미발생 )
# 최근검색어의 범위를 지정하는 것은 검색어를 저장할 각 딕셔너리의 리스트에, 공용 cnt + 1 하며 값을 함께 저장
# 튜플로 저장한다. ex) (cnt값, 검색어 문자열)
# 딕셔너리 리스트에 추가할 때 bisect.insort로 애초부터 cnt값을 기준으로 정렬하며 삽입한다.
# cnt 값에서 cnt - N 사이의 값만 추출 순회하면 해당 범위가 된다.
# -> 리스트를 순회하다가 N보다 작은 값이 나오면 탈출하면 나머지는 순회하지 않아도 된다.
# 노드 간선 연결을 어떻게 처리해야할까.
# 어차피 대표 검색어를 쓸꺼면, 대표 검색어 기준으로 유사도를 시작하면 되지 않을까?
# aaaa, aaaa, aaaa, aaab, aacb, aadb, ascb는 전부 유사 검색어인데,
# counter를 써서 aaaa를 가져오고, 그걸 기반으로 탐색을 들어간다.
# counter는 많이나온 순대로 보여주고, 몇개가 있는지도 보여주는것이다.
# 각 딕트 순회마다 카운팅 배열을 6개 생성
# 탐색 중 유사 검색어를 발견하면 해당 검색어를 또 유사검색어 list에 저장하고, dfs를 통해 쭉 계속 들어간다.
# 유사검색어의 유사검색어를 계속 탐색
# 유사검색어는 카운팅 배열을 사용, set형으로 저장한다. Top1의 유사검색어들은
# 각 딕트의 고유한 카운팅 배열의 1번째에 저장, counter 결과의 Top1의 유사검색어 탐색이 끝났으면,
# counter결과의 Top2와 set내부의 문자열을 비교한다. set안에 Top2..N이 있으면
# set와 비교 중 동일한 값이 있으면 그 값의 중복 수(몇개가 있는지)를 가져온 후 카운팅 배열에 더해준다.
# 또한 동일값이라면 visited를 또 만들어서 다음 탐색때는 탐색할 필요없도록 만든다.
# 먼저 글로벌 rank_list를 501개 배열(N <= 500)을 만들고, 각Dict를 순회하며 유사검색어를 찾으면 항상
# 각 Dict의 키 값과, 각 Dict리스트에서 몇번째 idx(몇번째 대표 검색어)의 유사검색어 인지(idx값)를 넣고, cnt를 증가시킨다.
# 이 건 새로운 대표검색어가 나올때마다 공통으로 공유하는 cnt를 +1 하면서 rank_list의 인덱스를 순회하며 값을 넣는다.
# 이거 반복(5개가 나오거나 dict순회를 끝마칠때 까지)
# 모든 dict를 순회한다.(만약 가지치기가 필요하면, 모든 dict에 counter를 날렸을때)
# 각 dict counter의 최소값의 5개보다 작은 dict 길이를 가지고 있는 dict(검색어가 애초에 작은 dict)는 이후에는 제외해도됨.
# 모든 dict를 순회한 후
# rank_list를 heapq를 이용하여
# Top 5개를 뽑는다.
# 5개의 dict 키값과 해당 키값의 인덱스 번호를 가져오고,
# 리스트에 문자열을 검색어를 넣은 뒤, cnt가 같은 경우 해당 문자열들만 슬라이싱을 통해 sort해준다.
# 끝
